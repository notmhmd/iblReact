import {
  useSlot
} from "./chunk-ZPJXK56S.js";
import {
  styled_default,
  useThemeProps
} from "./chunk-DZ6CTYGR.js";
import {
  generateUtilityClass,
  generateUtilityClasses
} from "./chunk-RSDJQATZ.js";
import {
  _objectWithoutPropertiesLoose,
  capitalize,
  composeClasses,
  init_esm,
  init_objectWithoutPropertiesLoose,
  require_prop_types,
  usePreviousProps_default
} from "./chunk-LAROEKPB.js";
import {
  _extends,
  init_extends
} from "./chunk-5FDQUWYF.js";
import {
  require_jsx_runtime
} from "./chunk-HSESELKR.js";
import {
  __toESM,
  require_react
} from "./chunk-YJNMHHGL.js";

// node_modules/@mui/joy/Badge/Badge.js
init_objectWithoutPropertiesLoose();
init_extends();
var React = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
init_esm();

// node_modules/@mui/joy/Badge/badgeClasses.js
function getBadgeUtilityClass(slot) {
  return generateUtilityClass("MuiBadge", slot);
}
var badgeClasses = generateUtilityClasses("MuiBadge", ["root", "badge", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft", "colorPrimary", "colorDanger", "colorNeutral", "colorSuccess", "colorWarning", "colorContext", "invisible", "locationInside", "locationOutside", "sizeSm", "sizeMd", "sizeLg", "variantPlain", "variantOutlined", "variantSoft", "variantSolid"]);
var badgeClasses_default = badgeClasses;

// node_modules/@mui/joy/Badge/Badge.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var _excluded = ["anchorOrigin", "badgeInset", "children", "size", "color", "invisible", "max", "badgeContent", "showZero", "variant", "component", "slots", "slotProps"];
var useUtilityClasses = (ownerState) => {
  const {
    color,
    variant,
    size,
    anchorOrigin,
    invisible
  } = ownerState;
  const slots = {
    root: ["root"],
    badge: ["badge", invisible && "invisible", anchorOrigin && `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`, variant && `variant${capitalize(variant)}`, color && `color${capitalize(color)}`, size && `size${capitalize(size)}`]
  };
  return composeClasses(slots, getBadgeUtilityClass, {});
};
var BadgeRoot = styled_default("span", {
  name: "JoyBadge",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})(({
  theme,
  ownerState
}) => _extends({}, ownerState.size === "sm" && _extends({
  "--Badge-minHeight": "0.5rem"
}, ownerState.badgeContent && {
  "--Badge-minHeight": "1rem"
}, {
  "--Badge-paddingX": "0.25rem"
}), ownerState.size === "md" && _extends({
  "--Badge-minHeight": "0.75rem"
}, ownerState.badgeContent && {
  "--Badge-minHeight": "1.25rem"
}, {
  "--Badge-paddingX": "0.375rem"
}), ownerState.size === "lg" && _extends({
  "--Badge-minHeight": "1rem"
}, ownerState.badgeContent && {
  "--Badge-minHeight": "1.5rem"
}, {
  "--Badge-paddingX": "0.5rem"
}), {
  "--Badge-ringSize": "2px",
  "--Badge-ring": `0 0 0 var(--Badge-ringSize) var(--Badge-ringColor, ${theme.vars.palette.background.surface})`,
  position: "relative",
  display: "inline-flex",
  // For correct alignment with the text.
  verticalAlign: "middle",
  flexShrink: 0
}));
var BadgeBadge = styled_default("span", {
  name: "JoyBadge",
  slot: "Badge",
  overridesResolver: (props, styles) => styles.badge
})(({
  theme,
  ownerState
}) => {
  var _ownerState$anchorOri, _ownerState$anchorOri2, _ownerState$anchorOri3, _ownerState$anchorOri4, _typography$lineHeigh, _theme$variants;
  const inset = {
    top: ownerState.badgeInset,
    left: ownerState.badgeInset,
    bottom: ownerState.badgeInset,
    right: ownerState.badgeInset
  };
  if (typeof ownerState.badgeInset === "string") {
    const insetValues = ownerState.badgeInset.split(" ");
    if (insetValues.length > 1) {
      inset.top = insetValues[0];
      inset.right = insetValues[1];
      if (insetValues.length === 2) {
        inset.bottom = insetValues[0];
        inset.left = insetValues[1];
      }
      if (insetValues.length === 3) {
        inset.left = insetValues[1];
        inset.bottom = insetValues[2];
      }
      if (insetValues.length === 4) {
        inset.bottom = insetValues[2];
        inset.left = insetValues[3];
      }
    }
  }
  const translateY = ((_ownerState$anchorOri = ownerState.anchorOrigin) == null ? void 0 : _ownerState$anchorOri.vertical) === "top" ? "translateY(-50%)" : "translateY(50%)";
  const translateX = ((_ownerState$anchorOri2 = ownerState.anchorOrigin) == null ? void 0 : _ownerState$anchorOri2.horizontal) === "left" ? "translateX(-50%)" : "translateX(50%)";
  const transformOriginY = ((_ownerState$anchorOri3 = ownerState.anchorOrigin) == null ? void 0 : _ownerState$anchorOri3.vertical) === "top" ? "0%" : "100%";
  const transformOriginX = ((_ownerState$anchorOri4 = ownerState.anchorOrigin) == null ? void 0 : _ownerState$anchorOri4.horizontal) === "left" ? "0%" : "100%";
  const typography = theme.typography[`body-${{
    sm: "xs",
    md: "sm",
    lg: "md"
  }[ownerState.size]}`];
  return _extends({
    "--Icon-color": "currentColor",
    "--Icon-fontSize": `calc(1em * ${(_typography$lineHeigh = typography == null ? void 0 : typography.lineHeight) != null ? _typography$lineHeigh : "1"})`,
    display: "inline-flex",
    flexWrap: "wrap",
    justifyContent: "center",
    alignContent: "center",
    alignItems: "center",
    position: "absolute",
    boxSizing: "border-box",
    boxShadow: "var(--Badge-ring)",
    lineHeight: 1,
    padding: "0 calc(var(--Badge-paddingX) - var(--variant-borderWidth, 0px))",
    minHeight: "var(--Badge-minHeight)",
    minWidth: "var(--Badge-minHeight)",
    borderRadius: "var(--Badge-radius, var(--Badge-minHeight))",
    zIndex: theme.vars.zIndex.badge,
    backgroundColor: theme.vars.palette.background.surface,
    [ownerState.anchorOrigin.vertical]: inset[ownerState.anchorOrigin.vertical],
    [ownerState.anchorOrigin.horizontal]: inset[ownerState.anchorOrigin.horizontal],
    transform: `scale(1) ${translateX} ${translateY}`,
    transformOrigin: `${transformOriginX} ${transformOriginY}`,
    [`&.${badgeClasses_default.invisible}`]: {
      transform: `scale(0) ${translateX} ${translateY}`
    }
  }, typography, {
    fontWeight: theme.vars.fontWeight.md
  }, (_theme$variants = theme.variants[ownerState.variant]) == null ? void 0 : _theme$variants[ownerState.color]);
});
var Badge = React.forwardRef(function Badge2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "JoyBadge"
  });
  const {
    anchorOrigin: anchorOriginProp = {
      vertical: "top",
      horizontal: "right"
    },
    badgeInset: badgeInsetProp = 0,
    children,
    size: sizeProp = "md",
    color: colorProp = "primary",
    invisible: invisibleProp = false,
    max = 99,
    badgeContent: badgeContentProp = "",
    showZero = false,
    variant: variantProp = "solid",
    component,
    slots = {},
    slotProps = {}
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  const prevProps = usePreviousProps_default({
    anchorOrigin: anchorOriginProp,
    size: sizeProp,
    badgeInset: badgeInsetProp,
    color: colorProp,
    variant: variantProp
  });
  let invisible = invisibleProp;
  if (invisibleProp === false && (badgeContentProp === 0 && !showZero || badgeContentProp == null)) {
    invisible = true;
  }
  const {
    color = colorProp,
    size = sizeProp,
    anchorOrigin = anchorOriginProp,
    variant = variantProp,
    badgeInset = badgeInsetProp
  } = invisible ? prevProps : props;
  const ownerState = _extends({}, props, {
    anchorOrigin,
    badgeInset,
    variant,
    invisible,
    color,
    size
  });
  const classes = useUtilityClasses(ownerState);
  const externalForwardedProps = _extends({}, other, {
    component,
    slots,
    slotProps
  });
  let displayValue = badgeContentProp && Number(badgeContentProp) > max ? `${max}+` : badgeContentProp;
  if (invisible && badgeContentProp === 0) {
    displayValue = "";
  }
  const [SlotRoot, rootProps] = useSlot("root", {
    ref,
    className: classes.root,
    elementType: BadgeRoot,
    externalForwardedProps,
    ownerState
  });
  const [SlotBadge, badgeProps] = useSlot("badge", {
    className: classes.badge,
    elementType: BadgeBadge,
    externalForwardedProps,
    ownerState
  });
  return (0, import_jsx_runtime2.jsxs)(SlotRoot, _extends({}, rootProps, {
    children: [children, (0, import_jsx_runtime.jsx)(SlotBadge, _extends({}, badgeProps, {
      children: displayValue
    }))]
  }));
});
true ? Badge.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The anchor of the badge.
   * @default {
   *   vertical: 'top',
   *   horizontal: 'right',
   * }
   */
  anchorOrigin: import_prop_types.default.shape({
    horizontal: import_prop_types.default.oneOf(["left", "right"]).isRequired,
    vertical: import_prop_types.default.oneOf(["bottom", "top"]).isRequired
  }),
  /**
   * The content rendered within the badge.
   * @default ''
   */
  badgeContent: import_prop_types.default.node,
  /**
   * The inset of the badge. Support shorthand syntax as described in https://developer.mozilla.org/en-US/docs/Web/CSS/inset.
   * @default 0
   */
  badgeInset: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]),
  /**
   * The badge will be added relative to this node.
   */
  children: import_prop_types.default.node,
  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   * @default 'primary'
   */
  color: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["danger", "neutral", "primary", "success", "warning"]), import_prop_types.default.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types.default.elementType,
  /**
   * If `true`, the badge is invisible.
   * @default false
   */
  invisible: import_prop_types.default.bool,
  /**
   * Max count to show.
   * @default 99
   */
  max: import_prop_types.default.number,
  /**
   * Controls whether the badge is hidden when `badgeContent` is zero.
   * @default false
   */
  showZero: import_prop_types.default.bool,
  /**
   * The size of the component.
   * @default 'md'
   */
  size: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["sm", "md", "lg"]), import_prop_types.default.string]),
  /**
   * The props used for each slot inside.
   * @default {}
   */
  slotProps: import_prop_types.default.shape({
    badge: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
    root: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: import_prop_types.default.shape({
    badge: import_prop_types.default.elementType,
    root: import_prop_types.default.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
  /**
   * The [global variant](https://mui.com/joy-ui/main-features/global-variants/) to use.
   * @default 'solid'
   */
  variant: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["outlined", "plain", "soft", "solid"]), import_prop_types.default.string])
} : void 0;
var Badge_default = Badge;

export {
  getBadgeUtilityClass,
  badgeClasses_default,
  Badge_default
};
//# sourceMappingURL=chunk-PP6YZFMJ.js.map
